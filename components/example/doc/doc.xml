<doc name="Muen Component Specification">
 <author>The Muen Team</author>
 <version>0.1</version>

 <latex_preamble>
  \usepackage{listings}

  \definecolor{mygreen}{rgb}{0,0.6,0}
  \definecolor{mygray}{rgb}{0.5,0.5,0.5}
  \definecolor{mymauve}{rgb}{0.58,0,0.82}

  \lstset{
  backgroundcolor=\color{white},
  basicstyle=\footnotesize\ttfamily,
  breakatwhitespace=false,
  breaklines=true,
  captionpos=b,
  commentstyle=\color{mygreen},
  extendedchars=true,
  rangeprefix=--D\ @Lst\ ,
  includerangemarker=false,
  frame=single,
  keepspaces=true,
  keywordstyle=\color{blue},
  language=Octave,
  numbers=left,
  numbersep=5pt,
  numberstyle=\tiny\color{mygray},
  rulecolor=\color{black},
  showspaces=false,
  showstringspaces=false,
  showtabs=false,
  stepnumber=2,
  stringstyle=\color{mymauve},
  tabsize=2,
  title=\lstname
  }
 </latex_preamble>

 <description scope="config" name="greeter">
  String configuration option example
 </description>

 <description scope="config" name="print_serial">
  Boolean configuration option example
 </description>

 <description scope="config" name="print_vcpu_speed">
  Another boolean configuration option example
 </description>

 <description scope="config" name="serial">
  Integer configuration option example
 </description>

 <section id="introduction" label="Introduction" priority="0">
  <text priority="0">
   In a component-based software architecture (\emph{CBA}), system functionality
   is realized by small, unprivileged applications, so called \emph{components}.

   The Muen Separation Kernel (SK) is a specialized microkernel, which allows
   the controlled execution of a software component as a \emph{subject}.
   Communication among subjects, and also between a subject and the kernel
   itself is strictly regulated by a system policy, which is enforced by the
   Muen SK.

   This document defines the foundation of Muen components, the interfaces,
   parameterization, documentation and verification. To illustrate these topics,
   an actual, runnable \emph{example} component is used.

   This document has been generated by analyzing the annotated source code of
   the example component and related sources, using repository version TODO:ref
   git describe.

   The following subsections first define the terms \emph{component},
   \emph{subject} and \emph{library}, before the actual component mechanisms are
   explained.
  </text>

  <section id="intro-component" label="Components" priority="0">
   <text priority="0">
    A component is a piece of software to be executed by the Muen separation
    kernel within a well-defined system partition. A Muen component consists of
    the following parts:

    \begin{itemize}
    \item Source code which is compiled into an executable binary
    \item Component specification
    \item Documentation
    \end{itemize}

    The component specification declares the binary program file including the
    virtual memory location as well as the logical view of the \emph{expected}
    execution environment. This environment is defined in terms of logical
    resources. Component resources can be of the type:

    \begin{itemize}
    \item Binary file
    \item Channel
    \item Logical memory
    \item Logical device
    \end{itemize}

    Listing \ref{code-xml-cspec} shows the component specification XML of the
    example component. First, the component defines configuration options which
    are used to parameterize the component (section
    \ref{parameterization_section}), then software library dependencies are
    declared (section \ref{intro-libraries}). The \texttt{requires} section
    specifies the \emph{expectations} the component has for its execution
    environment.

    \lstinputlisting[label=code-xml-cspec,caption=Component Specification
    XML,language=XML]{../../../policy/obj/cspecs/example.xml}

    The example component expects the following shared memory channels:
    \begin{itemize}
    \item \texttt{example\_request}
    \item \texttt{example\_response}
    \end{itemize}

    These are used to retrieve requests from a client, and to send a response
    (section \ref{interface_section}).

    An integrator must link the logical resources of a component specification
    file with the actual system policy. How this is done is specified in the Muen
    System Policy Specification document (TODO: name, link).

    The \texttt{provides} section specifies the sections of the component
    binary. These are auto-generated using the Mucbinsplit tool in this example.
   </text>
  </section>

  <section id="intro-subjects" label="Subjects" priority="0">
   <text priority="0">
    A subject is an instance of a component, i.e. an active entity that is
    executed by the Muen kernel during runtime. Its specification references a
    component and maps the requested logical resources to physical resources
    provided by the system.

    \lstinputlisting[label=code-subject-comp-map,caption=Mapping of component resources,language=XML]{../../../policy/xml/subject_example.xml}

    In listing \ref{code-subject-comp-map}, the three logical channels
    \texttt{example\_request}, \texttt{example\_reponse} and \texttt{debuglog}
    of the example component are mapped to physical channels of the system
    policy. Validators enforce that all requested resources of a component are
    properly mapped by the subject.

    Note that subjects do not need to have all resources specified in their
    component description. Instead, extra resources such as device and/or memory
    mappings can be implicitly assigned to a subject. This is useful for
    components which are able to enumerate the available resources at runtime by
    using configuration mechanism like PCI configuration space enumeration, ACPI
    or the Muen subject information page API specified in section
    \ref{Musinfo.Instance.Objectexample}.
   </text>
  </section>

  <section id="intro-libraries" label="Libraries" priority="0">
   <text priority="0">
    Generic parts of a software system are usually provided as software
    libraries. These libraries might be shared among multple components.

    In contrast to common software libraries, a Muen \emph{component library}
    also provides a library specification as seen in Listing
    \ref{code-libdebuglog-cspec}. Muen components declare a dependency to a
    library in the XML specification as shown in section \ref{intro-component}.
    If it is an SPARK/Ada library, they also declare the dependency in the GNAT
    project file. After that, the library is ready to be used in the component
    source code.

    \lstinputlisting[label=code-libdebuglog-cspec,caption=Libdebuglog library specification XML,language=XML]{../../libdebuglog/spec/libdebuglog.xml}

    The example XML specification also contains an \texttt{include} directive
    for another XML file: \texttt{config.xml}. This mechanism is used to
    generate configuration settings during the build depending on the actual
    system policy. This task is component-specific and can be implemented via
    various solutions, e.g. an XSLT transform or a python script to name just
    two.

    In this case, the size of the debugserver log channels is extracted from the
    system policy, see Listing \ref{code-libdebuglog-config-cspec}. More
    specifically, it contains the value for the \texttt{\$logchannel\_size}
    variable of the logical writer element as seen in Listing
    \ref{code-libdebuglog-cspec}.

    \lstinputlisting[label=code-libdebuglog-config-cspec,caption=Libdebuglog generated config.xml,language=XML]{../../libdebuglog/generated/config.xml}
   </text>
  </section>
 </section>

 <section id="resource-discovery" label="Resource Discovery" priority="0">
  <text priority="0">
   In order to interact with the environment, components must know the
   properties of resources like channels, memory or hardware devices. Depending
   on the actual resource, possible resource properties are virtual address,
   memory size, event or I/O port numbers.

   The Muen platform provides two main methods to learn about such resource
   properties. The main difference is the time the value of a concrete property
   is acquired:

   \begin{itemize}
   \item Build-time static
   \item Dynamic discovery at runtime
   \end{itemize}

   While the first mechanism is mainly used by native (SPARK/Ada) components,
   the second mechanism is often applied by a traditional guest virtual machine
   with a full-fledged OS. Since all resources are already known at
   compile-time, and because native (verified) components must be kept as simple
   as possible, they refrain from dynamic discovery and use constants generated
   by the CSPECS mechanism described in section \ref{cspecs}.

   An operating system like Linux tends to discover its resources at runtime.
   This is possible via the sinfo API introduced in section \ref{intro-sinfo}
   and specified in detail in section \ref{Musinfo.Instance.Objectexample}.

   While resources can be discovered via the sinfo and CSPECS mechanisms, there
   exist OS-specific discovery mechanism which are also supported by the Muen
   platform. These mechanisms are described in section
   \ref{intro-os-specific-discovery}.

   It is of course also possible to combine multiple methods as needed, like it
   is done in the example component or in the Muen Linux guest operating system.
  </text>

  <section id="cspecs" label="CSPECS Mechanism" priority="0">
   <text priority="0">
    The component specification in XML format outlined in section
    \ref{intro-component} and \ref{intro-libraries} is translated to SPARK/Ada
    specifications using the \texttt{mucgenspec} tool.

    The generated packages containing resource properties as SPARK/Ada constants
    are used in the source code of a component as illustrated in listing
    \ref{code-receiver}.

    \lstinputlisting[linerange=Reqbegin-Reqend,label=code-receiver,caption=Usage of CSPECS constants,language=Ada]{../src/foo-receiver.adb}
   </text>
  </section>

  <section id="intro-sinfo" label="Subject Information (sinfo) Mechanism" priority="0">
   <text priority="0">
    The Muen subject information (sinfo) and scheduling information (schedinfo)
    APIs allow the discovery of resource and scheduling data at runtime.

    The information is provided by mapping the subject info and scheduling info
    pages into the virtual address space of a component. This task is preformed
    by the \texttt{mucfgexpand} tool during the system build.

    A component must verify the validity of the sinfo page by calling the
    appropriate validation method. In a verified SPARK/Ada component, it must be
    shown that this property holds before calling an actual getter function of
    the sinfo API.

    Listing \ref{code-sinfo-khz} shows an exemplary sinfo API access in the code
    of the example component. The code acquires the start and end ticks of the
    current scheduling minor frame. This information can be used to implement a
    notion of relative time for example.

    \lstinputlisting[linerange=Sinfobegin-Sinfoend,label=code-sinfo-khz,caption=Acquiring minor frame tick range,language=Ada]{../src/example.adb}

    See section \ref{Musinfo.Instance.Objectexample} for the sinfo API
    specification.
   </text>
  </section>

  <section id="intro-os-specific-discovery" label="Operating System specific Methods" priority="0">
   <text priority="0">
    In order to make a Muen Linux guest discover its resources during runtime,
    the following methods are applied besides sinfo API lookup in the Muen
    drivers:

    \begin{itemize}
    \item ACPI tables
    \item Linux Zero-Page (ZP)
    \end{itemize}

    Static ACPI tables are generated by the \texttt{mugenacpi} tools and mapped
    into the virtual address space of a Linux guest by \texttt{mucfgexpand}.

    On the Intel x86 Architecture, Linux expects a so called zero-page (ZP) with
    information about initramfs location, kernel command line and console
    information mapped into its address space. These tasks are performed by
    \texttt{mugensinfo} and \texttt{mucfgexpand} respectively.

    Similar methods might be employed by other guest operating systems when
    porting them to Muen.
  </text>
  </section>
 </section>

 <section id="vm-vs-native" label="VCPU Profiles" priority="0">
  <text priority="0">
   A virtual CPU (vCPU) profile controls the execution behavior of the
   component's virtual CPU. It allows the specification of:

   \begin{itemize}
   \item Virtualization controls
   \begin{itemize}
   \item Runtime/Entry/Exit controls
   \item Exception host/guest handling
   \item CR0 host/guest ownership
   \item CR4 host/guest ownership
   \end{itemize}
   \item Direct MSR access
   \item Initial register values
   \begin{itemize}
   \item RIP
   \item RSP
   \item CR0
   \item CR4
   \item CS, DS segment register values
   \end{itemize}
   \end{itemize}

   VCPU profiles are assigned in the component specification at integration time
   and enforced by the SK. Muen currently differentiates two VCPU profiles which
   have different settings of the above:
   \begin{itemize}
   \item VCPU for native subjects
   \item VCPU for VM subjects
   \end{itemize}

   The VPCU profile of a native subject is much more restrictive, as Muen native
   subjects are written in SPARK with a zero-footprint (ZFP) runtime where
   absence of runtime errors is proven. Exception occurrence for such a component
   is a critical error which should be treated accordingly (TODO: Ref security
   best practices).

   A policy writer is free to define its own VCPU profile, but she should be
   aware of the security implications (TODO: Ref security best practices
   document).

   The current VCPU profiles for VM and native Muen components can be found in
   the Appendix, section \ref{appendix-vcpu}.
  </text>
 </section>

 <section id="parameterization_section" label="Configuration Parameters" priority="0">
  <text priority="-10">
   Components can be parameterized using the CSPEC mechanism as described in
   section \ref{cspecs}. This mechanism generates SPARK/Ada code from a
   component specification in XML format. One form of supported parameterization
   via CSPEC are the specification of configuration options. The example
   component provides three configuration option parameters as seen in the table
   below.
  </text>
  <text priority="0">
   Currently, the following configuration types are supported:

   \begin{itemize}
   \item Integer
   \item Boolean
   \item String
   \end{itemize}

   A component uses the generated constants to parameterize certain parts of the
   code. Listing \ref{code-config-opts} shows how the configuration options from
   the table above are used in the code of the example component.

   \lstinputlisting[linerange=Configbegin-Configend,label=code-config-opts,caption=Code parameterization using config options,language=Ada]{../src/example.adb}
  </text>
 </section>

 <section id="subject-monitoring" label="Subject Monitoring" priority="0">
  <text priority="0">
   The subject monitoring concept is used to have a designated subject to handle
   traps of another subject. This is useful for example to implement a
   trap-and-emulate approach for (VM) subjects or a debugger.

   On execution of a trapping instruction, the kernel hands over execution to
   the the configured subject monitor (SM) to deal with the event. A potential
   trap is the execution of the always trapping \texttt{CPUID} instruction for
   example.

   Handling of such an event can range from ignoring it to real device
   emulation using a device model. Execution might be handed back to the
   faulting subject after handling of the event.

   The system policy allows the configuration of a monitor subject as seen in
   Listing \ref{code-sm}.
   \lstinputlisting[linerange=138-142,label=code-sm,caption=Subject Monitor (SM) configuration in the policy,language=XML]{../../../policy/xml/genode-base_hw.xml}

   The policy writer defines the access permissions to the monitored subject
   state. The following state items are available:
   \begin{itemize}
   \item State\\CPU register state
   \item Timed Events\\Timed events of monitored subject
   \item Interrupts\\Interrupts of monitored subject
   \item Loader\\Loader mechanism used to reset monitored subject to initial state.
   \end{itemize}

   It is possible to define multiple state items per type, depending on the
   use-case.

   The following subsections introduce each state item shortly, before the
   actual interface API is presented.
  </text>

  <section id="subject-monitoring-state" label="Register State" priority="0">
   <text priority="0">
    The CPU register state is mapped into the monitor subject address space at
    the \texttt{virtualAddress} specified. The \texttt{writable} attribute
    specifies whether write access of the monitor subject is allowed.

    The SM register interface API is specified in section
    \ref{Subject_Info.Stateexample}.
   </text>
  </section>

  <section id="subject-monitoring-timed-evt" label="Timed Events" priority="0">
   <text priority="0">
    The timed events page of the monitored subject is mapped into the monitor
    subject address space at the \texttt{virtualAddress} specified. The
    \texttt{writable} attribute specifies whether write access of the monitor
    subject is allowed. The programming interface is the same as for the SM
    subject itself, see section \ref{Timed_Events.Timed_Evtexample}.

    The monitored timed event mechanism is useful if the monitored subject must
    be preempted at certain points in time, i.e. the execution must be handed
    over from the monitored subject to the SM subject to perform certain tasks.

    Note however, that currently the monitored subject also has unconditional
    access to its own timed events page and could therefore clear this event.
   </text>
  </section>

  <section id="subject-monitoring-timed-intrs" label="Interrupts" priority="0">
   <text priority="0">
    The subject interrupts page of the monitored subject is mapped into the monitor
    subject address space at the \texttt{virtualAddress} specified. The
    \texttt{writable} attribute specifies whether write access of the monitor
    subject is allowed.

    The interrupts page contains an array of four \texttt{SK.Word64} 64-bit
    Words, which designate the 256 interrupts to inject into the monitored
    subject.  The subject monitor uses this mechanism to inject arbitrary
    interrupts into the monitored subject (if write access is granted).
   </text>
  </section>

  <section id="subject-monitoring-timed-ldr" label="Loader" priority="0">
   <text priority="0">
    The memory regions of the monitored subject are mapped into the monitor
    subject address space at the specified offset \texttt{virtualAddress}
    specified. The \texttt{writable} attribute specifies whether write access to
    these regions by the monitor subject is allowed.

    Besides potential other use-cases, the loader concept can be applied to
    reset a subject to its initial state, perform decoding of a trapping
    instruction or to (periodically) check the memory contents of the monitored
    subject against hash sums.
   </text>
  </section>
 </section>

 <section id="verification_conditions_spark2014" label="Verification" priority="0">
  <text priority="-10">
   Muen is very well suited to work with verified SPARK/Ada components. The
   native VCPU profile is used to run such components as guest on top of the
   kernel.  The table below shows the verification results for the example
   component.
  </text>
 </section>

 <section id="interface_section" label="Interface API" priority="0">
  <text priority="0">
   This section specifies the interfaces of a Muen component. Where feasible,
   the example component interfaces are used to illustrate a specific interface.

   A Muen component has potential access to the following interfaces:

   \begin{itemize}
   \item Shared Memory Channels
   \item Assigned Devices
   \item Subject Information (sinfo, \ref{Musinfo.Instance.Objectexample})
   \item Subject Scheduling Information (schedinfo, \ref{Musinfo.Instance.Sched_Infoexample})
   \item Timed Events (\ref{Timed_Events.Timed_Evtexample})
   \item Traps (VM Exits)
   \item Hypercalls
   \item Subject Monitoring (\ref{Subject_Info.Stateexample})
   \end{itemize}

   Of course, it depends on the system policy of the actual system whether a
   component has access to a physical device, shared memory channel or similar
   resources. The sinfo, schedinfo and timed event interfaces on the other hand
   are currently unconditionally mapped into the address space of a component.
  </text>

  <section id="Timed_Events.Timed_Evtexample" label="Timed Events" priority="0"/>
  <section id="example_requestexample" label="Shared Memory Channel (Reader)" priority="0"/>
  <section id="example_responseexample" label="Shared Memory Channel (Writer)" priority="0"/>
  <section id="Subject_Info.Stateexample" label="Monitored Subject Register State" priority="0"/>
 </section>

 <section id="appendix" label="Appendix" priority="1000">
  <section id="appendix-vcpu" label="VCPU Profiles" priority="0">
   <text priority="0">
    \lstinputlisting[caption=Native VCPU,language=XML]{../../../tools/libmucfgvcpu/profiles/native.xml}
    \lstinputlisting[caption=VM VCPU,language=XML]{../../../tools/libmucfgvcpu/profiles/vm.xml}
   </text>
  </section>
 </section>

</doc>
