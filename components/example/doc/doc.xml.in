<doc name="Muen Component Specification">
 <author>Adrian-Ken Rueegsegger, Reto Buerki</author>
 <version>0.6</version>

 <latex_preamble>
  \usepackage{titlepic}
  \titlepic{\includegraphics[scale=0.4]{../../../doc/images/muen.pdf}}

  \usepackage{tocloft}
  \setcounter{tocdepth}{1}

  \usepackage[head=30pt, lmargin=3.0cm, rmargin=3.0cm, bmargin=1.9cm, tmargin=3.2cm]{geometry}

  \usepackage{hyperref}
  \hypersetup{
  pdftitle={Muen Component Specification},
  pdfsubject={Muen},
  pdfauthor={Adrian-Ken Rueegsegger, Reto Buerki},
  unicode=true,
  pdffitwindow=true,
  bookmarks=true,
  bookmarksnumbered=false,
  bookmarksopen=false,
  breaklinks=true,
  pdfborder={0 0 0},
  backref=false,
  colorlinks=true,
  }

  \definecolor{mygreen}{rgb}{0,0.6,0}
  \definecolor{mygray}{rgb}{0.5,0.5,0.5}
  \definecolor{mymauve}{rgb}{0.58,0,0.82}

  \usepackage{listings}
  \lstset{
  backgroundcolor=\color{white},
  basicstyle=\footnotesize\ttfamily,
  breakatwhitespace=false,
  breaklines=true,
  captionpos=b,
  commentstyle=\color{mygreen},
  extendedchars=true,
  rangeprefix=--D\ @Lst\ ,
  includerangemarker=false,
  frame=single,
  keepspaces=true,
  keywordstyle=\color{blue},
  language=Octave,
  numbers=left,
  numbersep=5pt,
  numberstyle=\tiny\color{mygray},
  rulecolor=\color{black},
  showspaces=false,
  showstringspaces=false,
  showtabs=false,
  stepnumber=2,
  stringstyle=\color{mymauve},
  tabsize=2,
  title=\lstname
  }

  \usepackage[T1]{fontenc}
  \usepackage{courier}
  \newcommand{\tablefont} {\fontfamily{pcr}\fontsize{8pt}{9pt}\selectfont}
  \let\oldlongtable\longtable
  \let\endoldlongtable\endlongtable
  \renewenvironment{longtable}{%
     \tablefont
     \oldlongtable
  }{\endoldlongtable}

  \newenvironment{warning}
  {\par
  \begin{list}{}{\leftmargin=1cm
  \labelwidth=\leftmargin}\item[\color{red}\Large\ding{43}]}
  {\end{list}\par}

  \newenvironment{info}
  {\par
  \begin{list}{}{\leftmargin=1cm
  \labelwidth=\leftmargin}\item[\color{blue}\Large\ding{43}]}
  {\end{list}\par}
 </latex_preamble>

 <description scope="config" name="ahci_drv_enabled">
  This knob controls whether or not the muenblock client code is enabled in the
  example component.
 </description>

 <description scope="config" name="greeter">
  String configuration option example
 </description>

 <description scope="config" name="print_serial">
  Boolean configuration option example
 </description>

 <description scope="config" name="print_vcpu_speed">
  Another boolean configuration option example
 </description>

 <description scope="config" name="serial">
  Integer configuration option example
 </description>

 <section id="introduction" label="Introduction" priority="0">
  <text priority="0">
   In a component-based software architecture (\emph{CBA}), system functionality
   is realized by small, unprivileged applications, so called \emph{components}.

   The Muen Separation Kernel (SK) is a specialized microkernel, which allows
   the controlled execution of a software component as a \emph{subject}.
   Communication among subjects, and also between a subject and the kernel
   itself is strictly regulated by a system policy, which is enforced by the
   Muen SK.

   This document defines the foundation of Muen components, the interfaces,
   parameterization, documentation and verification. To illustrate these topics,
   an actual, runnable \emph{example} component is used.

   This document has been generated by analyzing the annotated source code of
   the example component and related sources, using git repository revision
   \texttt{GITABBREVCOMMIT}.

   The following subsections first define the terms \emph{component},
   \emph{subject} and \emph{library}, before the actual component mechanisms are
   explained.
  </text>

  <section id="intro-component" label="Components" priority="0">
   <text priority="0">
    A component is a piece of software to be executed by the Muen separation
    kernel within a well-defined system partition. A Muen component consists of
    the following parts:

    \begin{itemize}
    \item Source code which is compiled into an executable binary
    \item Component specification
    \item Documentation
    \end{itemize}

    The component specification declares the binary program file including the
    virtual memory location as provided, file-backed memory regions, as well as
    the logical view of the \emph{expected} execution environment. This
    environment is defined in terms of logical resources. Component resources
    can be of the type:

    \begin{itemize}
    \item Provided memory regions with optional content
    \item Channel
    \item Logical memory
    \item Logical device
    \item Logical event
    \end{itemize}

    Listing \ref{code-xml-cspec} shows the component specification XML of the
    example component. First, the component defines configuration options which
    are used to parameterize the component (section
    \ref{parameterization_section}), then software library dependencies are
    declared (section \ref{intro-libraries}). The \texttt{requires} section
    specifies the \emph{expectations} the component has for its execution
    environment.

    \lstinputlisting[label=code-xml-cspec,caption=Component Specification
    XML,language=XML]{../../../policy/obj/cspecs/example.xml}

    The example component expects the following shared memory channels:
    \begin{itemize}
    \item \texttt{example\_request}
    \item \texttt{example\_response}
    \end{itemize}

    These are used to retrieve requests from a client, and to send a response
    (section \ref{interface_section}).

    The example component also expects the availability of two source events
    with given IDs, and it is the target endpoint for the \texttt{inject\_timer}
    event.

    An integrator must link the logical resources of a component specification
    with the actual system policy. How this is done is explained in section
    \ref{intro-subjects}.

    The \texttt{provides} section specifies memory regions which are provided by
    the component. Such regions will be added to the physical memory regions of
    the system and linked into the subject referencing the component. Usually,
    the provided regions consist of the component binary, but it is possible to
    provide arbitrary regions, with or without content.

    In order to simplify the integrators job, the \texttt{mucbinsplit} tool can
    be used to generate the component binary regions with the correct
    permissions automatically. See the \emph{Muen System Specification}
    \cite{muen:system-spec} document for a detailed description of the tool.
   </text>
  </section>

  <section id="intro-subjects" label="Subjects" priority="0">
   <text priority="0">
    A subject is an instance of a component, i.e. an active entity that is
    executed by the Muen kernel during runtime. Its specification references a
    component and maps the requested logical resources to physical resources
    provided by the system.

    \lstinputlisting[label=code-subject-comp-map,caption=Mapping of component resources,language=XML]{../../../policy/xml/subject_example.xml}

    In listing \ref{code-subject-comp-map}, the three logical channels
    \texttt{example\_request}, \texttt{example\_reponse} and \texttt{debuglog}
    of the example component are mapped to physical channels of the system
    policy via \texttt{map} elements. The \texttt{debuglog} channel is not
    directly visible in the \ref{code-subject-comp-map} listing, as it is added
    by the dependency to the libmudebuglog library (which is declared in the
    component XML listing \texttt{depends} section).

    Also, the requested source and target events are mapped to global system
    events.

    Validators enforce that all requested resources of a component are properly
    mapped by the subject.

    Note that subjects do not need to have all resources specified in their
    component description. Instead, extra resources such as device and/or memory
    mappings can be assigned to a subject. This is useful for components which
    are able to enumerate the available resources at runtime by using
    configuration mechanism like PCI configuration space enumeration, ACPI or
    the Muen subject information page API specified in section
    \ref{Musinfo.Instance.Objectexample}.
   </text>
  </section>

  <section id="intro-libraries" label="Libraries" priority="0">
   <text priority="0">
    Code which is used by multiple software components is usually factored out
    into a library to reduce code duplication. This is also possible for Muen
    components. In contrast to shared dynamic libraries of a generic
    multi-purpose OS, only the source code and policy resources are shared, not
    the address space of the library itself. The code lives separately in all
    components which use the library. Therefore, Muen component libraries can be
    seen as a static library in generic OS terms.

    A Muen \emph{component library} provides a library specification, like the
    example provided in listing \ref{code-libmudebuglog-cspec}. Muen components
    declare a dependency to a library in the XML specification as outlined in
    section \ref{intro-component}.  If the library in question is written in
    SPARK/Ada, the component project also declares the dependency in its GNAT
    project file. After that, the functionality provided by the software library
    is accessible from the component source code.

    \lstinputlisting[label=code-libmudebuglog-cspec,caption=Libmudebuglog library specification XML,language=XML]{../../libmudebuglog/spec/libmudebuglog.xml}

    Similar to components, the library \texttt{requires} certain resources to
    operate. In this case, a \texttt{debuglog} channel is expected at the given
    \texttt{virtualAddress} with the specified \texttt{size}. Note that the size
    is provided by a variable. The library intends to write to this shared
    memory channel as a channel \texttt{writer}. A component depending on this
    library inherits the requested resource from the library, and the system
    integrator must map them to physical system resources at the subject level
    as seen in the previous section.

    The example XML specification also contains an \texttt{include} directive
    for another XML file: \texttt{config.xml}. This mechanism is used to
    generate configuration settings during the build depending on the actual
    system policy. This task is component-specific and can be implemented via
    various solutions, e.g. an XSLT transform or a Python script to name just
    two. In this case, the size of the debugserver log channels is extracted
    from the system policy, see listing \ref{code-libmudebuglog-config-cspec}.
    More specifically, it contains the value for the \texttt{\$logchannel\_size}
    variable mentioned before in listing \ref{code-libmudebuglog-cspec}.

    \lstinputlisting[label=code-libmudebuglog-config-cspec,caption=Libmudebuglog generated config.xml,language=XML]{../../libmudebuglog/generated/config.xml}
   </text>
  </section>
 </section>

 <section id="resource-discovery" label="Resource Discovery" priority="0">
  <text priority="0">
   In order to interact with the environment, components must know the
   properties of resources like channels, memory or hardware devices. Depending
   on the actual resource, possible resource properties are virtual address,
   memory size, event or I/O port numbers.

   The Muen platform provides two main methods to learn about such properties.
   The main difference is the point in time the value of a property is acquired:

   \begin{itemize}
   \item Build-time static
   \item Dynamic discovery at runtime
   \end{itemize}

   While the first mechanism is mainly used by native (SPARK/Ada) components,
   the second mechanism is often applied by a traditional guest virtual machine
   with a full-fledged OS. Since all resources are already known at
   compile-time, and because native (verified) components must be kept as simple
   as possible, they refrain from dynamic discovery and use constants generated
   by the CSPECS mechanism described in section \ref{cspecs}.

   An operating system like Linux tends to discover its resources at runtime.
   This is possible via the sinfo API introduced in section \ref{intro-sinfo}
   and specified in detail in section \ref{Musinfo.Instance.Objectexample}.

   While resources can be discovered via the sinfo and Component Specifications
   (CSPECS) mechanisms, there exist OS-specific mechanisms to determine
   available resources, which are also supported by the Muen platform. These
   mechanisms are described in section \ref{intro-os-specific-discovery}.

   It is also possible to combine multiple methods as needed, like it is done in
   the example component or in the Muen Linux guest operating system where both
   generated ACPI tables and the sinfo API are employed to discover resources.
  </text>

  <section id="cspecs" label="CSPECS Mechanism" priority="0">
   <text priority="0">
    During the component build process, the component specification in XML
    format outlined in section \ref{intro-component} and \ref{intro-libraries}
    is translated to SPARK/Ada specifications using the \texttt{mucgenspec}
    tool, see \cite{muen:system-spec}.

    The generated packages in the \texttt{Example\_Component} hierarchy contain
    resource properties as constants for SPARK/Ada. These constants can be used
    in the source code of a component as illustrated in listing
    \ref{code-receiver}.

    \lstinputlisting[linerange=Reqbegin-Reqend,label=code-receiver,caption=Usage of CSPECS constants,language=Ada]{../src/foo-receiver.adb}

    The Ada record type representing the example request channel data is placed
    at the memory location designated in the component XML specification using Ada
    \texttt{Address} and \texttt{Volatile} aspects in combination with the
    CSPECs generated resource constants.
   </text>
  </section>

  <section id="intro-sinfo" label="Subject Information (sinfo) Mechanism" priority="0">
   <text priority="0">
    The Muen subject information (\emph{sinfo}) and scheduling information
    (\emph{schedinfo}) APIs allow the discovery of resource and scheduling data
    at runtime.

    The information is provided by mapping the subject info and scheduling info
    pages into the virtual address space of a subject. This task is performed
    automatically by the \texttt{mucfgexpand} tool during the system build (see
    \cite{muen:system-spec} for more information).

    A component must verify the validity of the sinfo page by calling the
    appropriate validation method. In a verified SPARK/Ada component, it must be
    shown that this property holds before calling an actual getter function of
    the sinfo API.

    Listing \ref{code-sinfo-khz} shows an exemplary sinfo API access in the code
    of the example component. The code acquires the start and end ticks of the
    current scheduling minor frame. This information can be used to implement a
    notion of relative time, or as a base for a virtual timer mechanism.

    \lstinputlisting[linerange=Sinfobegin-Sinfoend,label=code-sinfo-khz,caption=Acquiring minor frame tick range,language=Ada]{../src/example.adb}

    See section \ref{Musinfo.Instance.Objectexample} for the sinfo API
    specification.

    \begin{info}
    It should be noted that sinfo as well as scheduling info are read-only data
    structures mapped into a subjects address space. Accessing this information
    via the respective APIs essentially results in reading the corresponding
    value from memory. \emph{No direct interaction with other parts of the
    system, including and in particluar the Muen kernel, occurs}.
    \end{info}
   </text>
  </section>

  <section id="intro-os-specific-discovery" label="Operating System specific Methods" priority="0">
   <text priority="0">
    To allow resource discovery at runtime, the following additional methods are
    currently implemented for Linux VMs:

    \begin{itemize}
    \item ACPI tables
    \item Linux Zero-Page (ZP)
    \end{itemize}

    Static ACPI tables are generated by the \texttt{mugenacpi} tool and mapped
    into the virtual address space of a Linux guest by \texttt{mucfgexpand}.

    On the Intel x86 Architecture, Linux expects a so called zero-page (ZP) with
    information about initramfs location, kernel command line and console
    information mapped into its address space. These tasks are performed by
    \texttt{mugenzp} and \texttt{mucfgexpand} respectively.

    Refer to the Muen System Specification \cite{muen:system-spec} for more
    information about the involved tools.

    Similar methods might be employed by other guest operating systems when
    porting them to Muen.
  </text>
  </section>
 </section>

 <section id="vm-vs-native" label="VCPU Profiles" priority="0">
  <text priority="0">
   A virtual CPU (vCPU) profile controls the execution behavior of the
   component's virtual CPU. It allows the specification of:

   \begin{itemize}
   \item Virtualization controls
   \begin{itemize}
   \item Runtime/Entry/Exit controls
   \item Exception host/guest handling
   \item CR0 host/guest ownership
   \item CR4 host/guest ownership
   \end{itemize}
   \item Direct MSR access
   \item Initial register and segment values
   \end{itemize}

   VCPU profiles are assigned in the component specification at integration time
   and enforced by the SK. Muen differentiates two vCPU profiles which have
   different settings of the above:
   \begin{itemize}
   \item vCPU for native subjects
   \item vCPU for VM subjects
   \end{itemize}

   The vCPU profile of a native subject is much more restrictive, as Muen native
   subjects are written in SPARK/Ada with a zero-footprint (ZFP) runtime where
   absence of runtime errors is proven. Exception occurrence for such a
   component is a critical error which should be treated accordingly.

   The validator tool \texttt{mucfgvalidate} ensures that the invariants for the
   proper execution of the Muen SK hold. This is done during integration, by
   verifying the vCPU profile of each subject. The kernel itself does not modify
   these settings during runtime. For example, it is not allowed to disable the
   VMX preemption timer of a subject, as this is the mechanism used by the SK to
   preempt subjects according to the scheduling plan.

   See the Muen System Specification \cite{muen:system-spec} document for the
   specification of all elements of a vCPU profile. The current vCPU profiles
   for VM and native Muen components can be found in the Appendix, section
   \ref{appendix-vcpu}.
  </text>
 </section>

 <section id="parameterization_section" label="Configuration Parameters" priority="0">
  <text priority="-10">
   Components can be parameterized using the CSPEC mechanism as described in
   section \ref{cspecs}. This mechanism generates SPARK/Ada code from a
   component specification in XML format. Another form of supported
   parameterization based on the CSPEC mechanism are the specification of
   configuration options. Again, this section uses the \emph{example} component
   as illustration.
  </text>
  <text priority="0">
   As listed in the table above, the following configuration types are
   supported:

   \begin{itemize}
   \item Integer
   \item Boolean
   \item String
   \end{itemize}

   A component can use the generated constants to parameterize certain parts of
   the code. Listing \ref{code-config-opts} shows how the configuration options
   from the table above are used in the code of the \emph{example} component.

   \lstinputlisting[linerange=Configbegin-Configend,label=code-config-opts,caption=Code parameterization using config options,language=Ada]{../src/example.adb}

   The example serial number and the vCPU speed are only printed if the
   respective \texttt{boolean} configuration options are set to \texttt{true} in
   the component specification XML.\footnote{\texttt{pragma Debug} only executes
   the statement after the colon if the boolean expression before the colon is
   true}
  </text>
 </section>

 <section id="subject-monitoring" label="Subject Monitoring" priority="0">
  <text priority="0">
   The subject monitoring concept consists of having a designated subject handle
   traps of another subject. This is useful for example to implement a
   trap-and-emulate approach for VM subjects or a debugger.

   On execution of a trapping instruction in the monitored subject, the kernel
   hands over execution to the configured subject monitor (SM) to deal with the
   event. A potential trap is the execution of \texttt{CPUID} instruction for
   example\footnote{CPUID always traps in VMX non-root mode}.

   Handling of such an event can range from ignoring it to fully-fledged device
   emulation using a device model. Execution might be handed back to the
   faulting subject after handling of the event.

   The system policy allows the configuration of a monitor subject as seen in
   listing \ref{monitor-policy}.

   \lstinputlisting[linerange=11-14,label=monitor-policy,caption=Subject Monitor
   (SM) configuration in the policy,language=XML]{../../../policy/xml/subject_example.xml}

   The policy writer defines the access permissions to the monitored subject
   state. The following state items are available:
   \begin{itemize}
   \item State\\CPU register state of monitored subject
   \item Timed Events\\Timed events of monitored subject
   \item Interrupts\\Interrupts of monitored subject
   \item Loader\\Loader mechanism used to reset monitored subject to initial state
   \end{itemize}

   It is possible to define multiple state items per type, referencing different
   subjects.

   The self-referencing \texttt{loader} element shown in listing
   \ref{monitor-policy} is part of the subject lifecycle mechanism explained in
   section \ref{subject-lifecycle}.

   The following subsections introduce each state configuration shortly, before
   the actual interface API is presented. See the Muen System Specification
   \cite{muen:system-spec} for more details on the \texttt{monitor} element and
   its implications.
  </text>

  <section id="subject-monitoring-state" label="Register State" priority="0">
   <text priority="0">
    The CPU register state of the monitored subject is mapped into the monitor
    subject address space at the \texttt{virtualAddress} specified. The
    \texttt{writable} attribute specifies whether write access of the monitor
    subject is allowed. A monitor with write access can alter the CPU register
    state of the monitored subject at runtime.

    The SM register interface API is specified in section
    \ref{Subject_Info.Stateexample}.
   </text>
  </section>

  <section id="subject-monitoring-timed-evt" label="Timed Events" priority="0">
   <text priority="0">
    The timed events page of the monitored subject is mapped into the monitor
    subject address space at the specified \texttt{virtualAddress}. The
    \texttt{writable} attribute defines whether write access of the monitor
    subject is allowed. The programming interface is the same as for the SM
    subject itself, see section \ref{Timed_Events.Timed_Evtexample}.

    The monitored timed event mechanism is useful if the monitored subject
    should be preempted at certain points in time, i.e. the execution should be
    handed over from the monitored subject to the SM subject to perform certain
    tasks.

    \begin{warning}
    Currently, the monitored subject has unconditional access to its own timed
    events page and could therefore clear the event set by the monitor. The
    mechanism is therefore not suitable to \emph{enforce} preemption.
    \end{warning}
   </text>
  </section>

  <section id="subject-monitoring-timed-intrs" label="Interrupts" priority="0">
   <text priority="0">
    The subject interrupts page of the monitored subject is mapped into the
    monitor subject address space at the specified \texttt{virtualAddress}. The
    \texttt{writable} attribute designates whether write access by the monitor
    subject is allowed.

    The interrupts page contains an array of four 64-bit words, which designate
    the 256 interrupts to inject into the monitored subject.  The subject
    monitor can use this mechanism to inject arbitrary interrupts into the
    monitored subject (if write access is granted).
   </text>
  </section>

  <section id="subject-monitoring-timed-ldr" label="Loader" priority="0">
   <text priority="0">
    The memory regions of the monitored subject are mapped into the monitor
    subject address space at the specified \texttt{virtualAddress}. The
    \texttt{writable} attribute specifies whether write access to these regions
    is allowed for the SM.

    Besides potential other use-cases, the loader concept can be applied to
    reset a subject to its initial state, perform decoding of a trapping
    instruction or to (periodically) check the memory content of the monitored
    subject against hash sums.

    See the Muen System Specification \cite{muen:system-spec} for the definition
    of the loader element with an in-depth description of the mechanism (element
    \texttt{loader}, type \texttt{loaderSubjectRefType}).
   </text>
  </section>

  <section id="subject-monitoring-example" label="By Example" priority="0">
   <text priority="0">
    This section illustrates the monitoring concept using the SM component for
    Linux, which is part of the Muen ecosystem of available components written
    in SPARK 2014. It is used to enable the execution of Linux as a VM subject
    on Muen.

    The SM component has the CPU register state of the associated monitored
    Linux VM mapped. Since the SM for Muen Linux is quite simple, it only maps
    the CPU register state, the timed event/interrupt pages and loader
    functionality is not required to fulfill its task.

    SM declares a package-level \texttt{State} variable of type
    \texttt{SK.Subject\_State\_Type}, as specified in section
    \ref{Subject_Info.Stateexample}. The address of the variable in memory must
    be set using the Ada \texttt{Address} aspect, with the value as configured
    in the SM component \texttt{monitor/state} specification. The
    \texttt{Volatile} aspect must be used as well, to tell the compiler that the
    value of this variable may change outside of the programming language
    boundary.

    Using the \texttt{State} variable, SM is able to inspect and alter the
    subject CPU register state of the monitored subject after a trap. For
    illustrative purposes, it is assumed that the monitored subject executes the
    \texttt{CPUID} instruction, which always traps in VMX non-root mode. The
    policy is setup so that a handover from the monitored subject to SM occurs
    in this case. The following snippet shows the XML \texttt{events} section of
    the monitored subject:

    \lstinputlisting[caption=CPUID event,language=XML]{sm_policy_trap.xml}

    On \texttt{CPUID}\footnote{Event IDs correspond to the VMX Basic Exit
    Reason, Intel SDM Vol. 3D, Appendix C} in the monitored subject, the kernel
    inspects the events table of the subject after exit and, according to its
    static configuration, hands over execution to SM.

    SM first examines the exit reason of the associated subject, by using the
    aformentioned \texttt{State} variable:

    \lstinputlisting[linerange=Smexitbegin-Smexitend,label=code-sm-exit-reason,caption=Determining
    the exit reason,language=Ada]{../../sm/src/sm.adb}

    If it concludes that the exit was caused by the execution of \texttt{CPUID},
    it calls the exit handler for this exit reason. It does the same for other
    exit reasons of interest. If there is no handler for a specific exit reason,
    execution of the monitored subject is halted by stopping the vCPU. This is
    done by calling \texttt{SK.CPU.Stop}, which executes \texttt{cli; hlt} in a
    loop. By not returning to the monitored subject, the cooperative scheduling
    group is now in a halted state.

    The \texttt{CPUID.Process} procedure called on a \texttt{CPUID} exit
    emulates a vCPU with certain features.  Therefore, depending on the
    requested CPUID leaf in the \texttt{RAX} register, the CPU register state is
    updated to reflect the result of the \texttt{CPUID} instruction back to the
    monitored subject:

    \lstinputlisting[linerange=Smcpuidbegin-Smcpuidend,label=code-sm-cpuid,caption=CPUID
    emulation of leaf 0,language=Ada]{../../sm/src/exit_handlers-cpuid.adb}

    After that, the SM main procedure is instructed to continue monitored
    subject execution by setting the \texttt{Action} out parameter of the
    \texttt{Process} procedure to \texttt{Subject\_Continue}. The SM main
    procedure then resumes the monitored subject by increasing the \texttt{RIP}
    and calling the hypercall procedure with event ID designated by the
    \texttt{Events.Resume\_Subject\_ID} constant. This triggers a handover back
    to the monitored subject:

    \lstinputlisting[linerange=Smresumebegin-Smresumeend,label=code-sm-resume,caption=End
    of SM main loop,language=Ada]{../../sm/src/sm.adb}

    The monitored subject then continues execution at the instruction following
    \texttt{cpuid} in the scheduling slot of SM until the next trap occurs.
   </text>
  </section>
 </section>

 <section id="subject-lifecycle" label="Subject Lifecycle" priority="0">
  <text priority="0">
   The subject lifecycle management concept provides a lightweight mechanism to
   intialize and reset native subjects. It allows to set up the memory resource
   of a subject to a well-known state prior to the execution of subject code.

   The initialization of the subject runtime environment is performed by a dedicated
   setup stub that runs before the effective subject code starts execution. To
   enable external management and synchronization, the current lifecycle state
   is reported via a so called \emph{Status Page} (detailed description see
   \ref{Mucontrol.Status.Instance.Status_Pageexample}). Commands are read from
   a \emph{Command Page} (see \ref{Mucontrol.Command.Instance.Command_Pageexample}).
   The commands are written by an external control/management subject
   (controller) that orchestrates all subjects under its purview.

   A watchdog (WD) timer mechanism instructs a subject to update a value on the
   status page in regular intervals. This enables the controller subject to
   determine if a subject is alive or has become stuck. The watchdog value must
   be updated within the desired period during regular subject execution,
   outside of the initialization code/stub.

   The current epoch value, communicated as part of the command interface,
   differs between subject restarts.
  </text>

  <section id="subject-lifecycle-policy_config_compilation" label="Policy / Config / Compilation" priority="0">
   <text priority="0">
    On the policy level, the initialization stub is treated as a library. To
    activate the init/reset functionality, a component simply declares a
    dependency in the component XML specification, see \ref{subject-lifecycle-usage-cspec}.
   </text>
   <section id="subject-lifecycle-policy_config_compilation-memory" label="Memory" priority="0">
    <text priority="0">
     Read-only copies of writable memory regions and matching hashes must be
     specified in the subject specification. The monitor/loader mechanism with a
     reference to self can be used so the mappings are swapped/complemented with
     read-only source regions. This way all necessary regions are made
     reloadable by the expander.
    </text>
   </section>
   <section id="subject-lifecycle-policy_config_compilation-entry" label="Entry Point" priority="0">
    <text priority="0">
     The RIP is set in the XML specification of the \texttt{Muinit} library.
     Since \texttt{Mucbinsplit} will not overwrite an already present vCPU
     \texttt{rip} value, no other change is necessary.  After initialization, a
     jump to the start address of the text memory region is performed to start
     execution of the actual subject code.

     The text memory region is defined as follows:
     \begin{itemize}
     \item Logical name: text
     \item Type: subject\_binary
     \item Executable: True
     \item Writable: False
     \item Content: file-backed
     \end{itemize}
    </text>
   </section>
   <section id="subject-lifecycle-policy_config_compilation-compilation" label="Compilation" priority="0">
    <text priority="0">
     While on the policy level, the initialization code is treated as a library,
     on the source level it is compiled and linked as an independent binary.
     This avoids mixing of text, data etc of the init and the actual component
     code, which is beneficial for certification. Additionally, the
     initialization can perform a complete reset of the component memory without
     interfering with its own state.

     The initialization code is linked to a different address
     (\verb!16#0010_0000#!) than regular Ada/SPARK component binaries
     (\verb!16#0020_0000#!) to enable co-existence in the same address space.
    </text>
   </section>
  </section>
  <section id="subject-lifecycle-interfaces" label="Command and Status Interface" priority="0">
   <text priority="0">
    The initialization code implements a simple state machine by waiting for a
    specific, expected command, executing the associated action and then
    reporting completion of said action by updating the status.

    A special command value \verb!Mucontrol.Commands.CMD_SELF_CTRL! designates that the
    initialization code should not wait for further instructions but instead
    perform initialization in one go.

    A watchdog interval of \verb!Mucontrol.Commands.WD_DISABLED! designates that watchdog
    functionality is disabled.

    For the detailed specification of the \emph{Command Interface} see section
    \ref{Mucontrol.Command.Instance.Command_Pageexample}. The \emph{Status Interface} is
    specified in section \ref{Mucontrol.Status.Instance.Status_Pageexample}.
   </text>
  </section>
  <section id="subject-lifecycle-usage" label="Usage" priority="0">
   <text priority="0">
    This section describes the XML adjustments which are required to make a
    component / subject reloadable.
   </text>
   <section id="subject-lifecycle-usage-system_policy" label="System Policy" priority="0">
    <text priority="0">
     Add physical memory regions to back new control and status pages.

     \lstinputlisting[label=subject-lifecycle-usage-policy-memory,caption=Declaration of Control and Status memory regions,language=XML]{restart-memory.xml}

     If a subject is placed under self-control, the fill pattern of the control
     page can be set to \verb!16#ff#!. In that case the corresponding status
     page must have fill pattern \verb!16#00#! to ensure proper initialization
     as the self-controlled subject may not access the status page at all.
     Since both memory regions are used during initialization, the hash of these
     two regions is set to none. With this, they are skipped during hash
     validation without having to implement some form of special-casing in the
     init stub.

     Add a physical reset event.

     \lstinputlisting[label=subject-lifecycle-usage-policy-event,caption=Declaration of the Reset event,language=XML]{restart-event.xml}
    </text>
   </section>
   <section id="subject-lifecycle-usage-cspec" label="Component Specification" priority="0">
    <text priority="0">
     Add a dependency to \verb!Muinit!.

     \lstinputlisting[label=subject-lifecycle-usage-cspec-dep,caption=Dependency declaration,language=XML]{restart-cspec.xml}

     If a component requires access to the status and command pages during
     execution, i.e. beyond the initialization, also add a dependency on
     \verb!libmucontrol!. Examples for this use case are updating the Watchdog Timer
     Value or Time subject of the demo system setting the runtime status to
     \verb!STATE_FINISHED! after successfully publishing time information.
    </text>
   </section>
   <section id="subject-lifecycle-usage-subject" label="Subject Specification" priority="0">
    <text priority="0">
     On the subject level, the following steps are necessary:
     \begin{itemize}
     \item Add mappings for Control and Status memory regions.
     \item Map reset event with ID 63 to give it the highest priority. This makes sure that if a reset event is pending it will be performed upon the next entry into the subject.
     \item Add loader element with reference to the subject itself.
     \end{itemize}

     \lstinputlisting[,label=subject-lifecycle-usage-subject_spec,caption=Adjustments to Subject Specification,language=XML]{restart-subject.xml}
    </text>
   </section>
  </section>
  <section id="subject-lifecycle-operation" label="Operation" priority="0">
   <text priority="0">
    This section gives a description of the high-level operation.
    \begin{figure}[ht]
    \centering
    \includegraphics[width=\textwidth]{subject_init_fsm}
    \label{fig-subject_init_fsm}
    \caption{Subject Initialization State Machine}
    \end{figure}

    The Subject Initialization Stub implements the finite state machine depicted
    in figure ~\ref{fig-subject_init_fsm}. Transitions are perfomed when the
    init code is in the given state and the specified command is read from the
    command interface. Table \ref{tab-lifecycle-fsm-commands} lists the commands
    issued by the controller and the action performed by the Subject
    Initialization code.

    \begin{table}[h!]
     \begin{center}
      \begin{tabular}{|l|p{0.7\linewidth}|}
       \hline
       \textbf{Command} &amp; \textbf{Action}\\
       \hline
       Sync &amp;	Set status to SYNCED and wait for next command\\
       Erase	&amp;	Zeroize writable memory regions\\
       Prepare	&amp; Set initial content of writable memory regions by copying data from corresponding read-only regions with matching hash\\
       Validate	&amp; Calculate and compare hashes for all memory regions that specify a hash. Report failure if a hash mismatch is detected\\
       Run	&amp; Set initial register values, clean up stack, set status running and jump to subject code\\
       Self-Control &amp;	Perform all initialization steps and start running subject code without further command processing\\
       \hline
      \end{tabular}
      \caption{Commands and their associated actions}
      \label{tab-lifecycle-fsm-commands}
     \end{center}
    \end{table}

    \begin{warning}
    Since the Status Interface is writable by the potentially untrustworthy
    component code, its content can only be relied upon after the delivery of
    the reset event up until setting command to \verb!CMD_RUN! and observing
    the status \verb!STATE_RUNNING!. The reset event assures that the init code
    is executed and that the component cannot simply fake transitions by
    operating on the status page.
    \end{warning}
   </text>
   <section id="subject-lifecycle-operation-init" label="Initialization" priority="0">
    <text priority="100">
     \begin{info}
     On \verb!CMD_SELF_CTRL! the subject may perform all of the above steps,
     without further synchronization/waiting for additional commands.
     \end{info}
     \begin{warning}
     Since the Assembley uses a a few registers to perform stack clearing etc,
     the registers R10-R15 will not retain their initial value. A component or
     subject must not make use of the initial values of these registers.
     \end{warning}
    </text>
   </section>
   <section id="subject-lifecycle-operation-vm" label="VM Components" priority="10">
    <text priority="0">
     For VM subjects, the same procedure as for native subjects is not viable
     (e.g. 2 level page tables would require IA32-e mode transition and
     creation of initial page tables etc.). Thus, we build on the existing
     loader concept. One simplification is that a loader only needs to support a
     single VM subject and no native subjects.

     Since the subject loader (SL) in effect performs the same functionality as
     the initialization/reset stub for native subjects, it directly operates on
     the status and command pages which are associated with the VM subject. It
     has no status/command pages for itself. The necessary Status and Command
     pages are added to the loader component XML specification by declaring a
     library dependency on \verb$libmucontrol$.

     Since the Loader, the corresponding Linux subject as well as the associated
     SM are part of the same scheduling group, a form of light cooperation
     between SM and SL is necessary. The initialization process is as follows:

     \begin{enumerate}
     \item SM starts execution of its own initialization code. Synchronization
           with the controller component happens as described above. The
           Controller can force handover to SM by resetting Linux state.
     \item After successful setup, SM enters main loop with "Invalid guest
           state" as Linux exit reason.
     \item SM checks if Linux reset event is available. If SM Sinfo does not
           contain \verb$Reset_Linux$ event \rightarrow go to step 9.
     \item Trigger \verb$Reset_Linux$ event. This results in handover to Linux
           with reset target action. The initial Linux state has
           \verb$CR4.VMXE = 0$, which triggers an immediate handover back to SM
           due to "Invalid guest state".
     \item Trigger \verb$Load_Linux$ event to handover execution to SL.
     \item SL syncs with controller component.
     \item SL performs Linux memory initialization using the same code as the
           native subject initialization, reused via the Libmuinit library.
     \item After successful setup of Linux memory, SL triggers a handover to SM.
     \item SM inspects Linux Status Interface filled in by SL to check that no
           error occured.
     \item If Linux State has Error bit set, print error message and halt
           subject execution.
     \item Check if SM is monitoring an AP Linux (\verb$CR0.PE = 0$): wait for
           wakeup event.
     \item SM makes Linux runnable by setting \verb$CR4.VMXE$ in Linux subject
           state.
     \item SM triggers handover to Linux thereby starting its execution.
     \end{enumerate}

     Except for the handover events passing on the thread of execution (without
     interrupt injection), SL and SM do not communicate directly.

     \begin{info}
      With this division of labor between SM and SL each subject has somewhat
      complementary privileges regarding the Linux subject: SM has access to the
      subject state while SL only has access to Linux's memory.
     \end{info}
     \begin{info}
      SL itself does not need reset functionality since it does not keep any
      state. This also enables 1:1 reuse of Libmuinit just as Muinit does.
     \end{info}
     \begin{info}
      SM maps the Linux Status page read-only to check for error conditions on
      loading Linux by SL. This avoids having an additional signalisation
      mechanism between SM and SL.
     \end{info}
    </text>
   </section>
  </section>
 </section>

 <section id="verification_conditions_spark2014" label="Verification" priority="0">
  <text priority="-10">
   Muen is very well suited to work with verified SPARK/Ada components. The
   native vCPU profile is used to run such components as guest on top of the
   kernel.  The table below shows the verification results for the example
   component.
  </text>
 </section>

 <section id="interface_section" label="Interface API" priority="0">
  <text priority="0">
   This section specifies the interfaces of a Muen component. Where feasible,
   the \emph{example} component interfaces are used to illustrate a specific
   interface.

   A Muen component has potential access to the following interfaces:

   \begin{itemize}
   \item Shared Memory Channels
   \item Assigned Devices
   \item Subject Information (sinfo, \ref{Musinfo.Instance.Objectexample})
   \item Subject Scheduling Information (schedinfo, \ref{Musinfo.Instance.Sched_Infoexample})
   \item Timed Events (\ref{Timed_Events.Timed_Evtexample})
   \item Traps (VM Exits)
   \item Hypercalls
   \item Subject Monitoring (\ref{Subject_Info.Stateexample})
   \item Subject Lifecycle (\ref{Mucontrol.Command.Instance.Command_Pageexample}, \ref{Mucontrol.Status.Instance.Status_Pageexample})
   \end{itemize}

   Of course, it depends on the system policy of the actual system whether a
   component has access to a physical device, shared memory channel or similar
   resources. The sinfo, schedinfo and timed event interfaces on the other hand
   are currently unconditionally mapped into the address space of a component.

   The following sections outline each interface in detail. The initial table
   shows the virtual address the interface is accessible in the component,
   potential size and access permissions. After that, the purpose of the
   interface is explained before specifying the exact structure.
  </text>

  <section id="Timed_Events.Timed_Evtexample" label="Timed Events" priority="0"/>
  <section id="example_requestexample" label="Shared Memory Channel (Reader)" priority="0"/>
  <section id="example_responseexample" label="Shared Memory Channel (Writer)" priority="0"/>
  <section id="Subject_Info.Stateexample" label="Monitored Subject Register State" priority="0"/>
 </section>

 <section id="appendix" label="Appendix" priority="1000">
  <section id="appendix-vcpu" label="VCPU Profiles" priority="0">
   <text priority="0">
    \lstinputlisting[caption=Native vCPU,language=XML]{../../../tools/libmucfgvcpu/profiles/native.xml}
    \lstinputlisting[caption=VM vCPU,language=XML]{../../../tools/libmucfgvcpu/profiles/vm.xml}
   </text>
  </section>
 </section>

</doc>
