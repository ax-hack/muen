<doc name="Muen Separation Kernel">
 <author>Adrian-Ken Rüegsegger, Reto Bürki</author>
 <version>0.1</version>

 <latex_preamble>
  \usepackage{acronym}

  \begin{tikzfadingfrompicture}[name=flow fade]
   \shade[left color=transparent!0,
           right color=transparent!60] (0,0) rectangle (2,2);
  \end{tikzfadingfrompicture}
  \input{tikzstyle}
 </latex_preamble>

 <section id="introduction" label="Introduction" priority="0">
  <text priority="0">
   This document describes the Muen Separation Kernel (SK). It is intended to
   give the reader a better understanding of the SK design and its
   implementation. Documentation is generated based on annotations in the SK
   source code\footnote{Version: //{str:SK.Version.Version_String}}.
  </text>
  <section id="intro_scope" label="Scope" priority="0">
   <text priority="0">
    Scope and objectives of this document.
   </text>
  </section>
  <section id="intro_structure" label="Document structure" priority="0">
   <text priority="0">
    Description of the document structure.
   </text>
  </section>
 </section>

 <section id="overview" label="Overview" priority="0">
  <text priority="0">
   This section gives a short overview of the design and architecture of the
   Muen Separation Kernel.
  </text>
  <section id="overview_architecture" label="System Architecture" priority="0">
   <text priority="0">
    This section describes the architecture of systems running on the Muen SK.

    Muen is an open-source Separation Kernel implemented in the SPARK
    programming language, which has been shown to be free from certain bug
    classes through the application of formal methods. It leverages the
    virtualization extensions provided by the hardware platform to securely
    isolate components and devices. Virtualization events such as traps are not
    handled by the SK but instead by components which enables the realisation of
    a kernel with low complexity.

    \begin{figure}[ht]
     \centering
     \input{graph_arch}
     \label{fig-muenarch}
     \caption{Execution of VMs and nativ Subjects on top of the Muen SK. The Kernel runs in privileged Intel VT-x root mode, all Subjects in unprivileged non-root mode.}
    \end{figure}

    The formally proven Muen SK is the only part of the system running in VMX
    root mode: all components, be it fully-fledged VMs or small, native
    subjects, execute with lower privileges in non-root mode. By design, no code
    is executed in userspace (ring 3) of VMX root mode. This enables Muen to
    completely forgo code for handling Syscalls/Ring-3-to-Ring-0 transitions,
    further reducing the code size and complexity.
   </text>
  </section>
 </section>

 <section id="datamodel" label="Data Model" priority="0">
  <text priority="0">
   Each CPU executes a distinct instance of the Muen kernel. By default, all
   kernel data is CPU-local, meaning it is not shared between the kernels
   running on different CPUs. Global data is shared explicitly and is designated
   as such by placing it in a dedicated section (.globaldata).

   Kernel data can be categorized as follows:
   \begin{itemize}
    \item CPU-local data
    \item CPU-local, subject-related data
    \item Global data, shared by all CPUs
   \end{itemize}
  </text>
  <section id="datamodel_cpulocal" label="CPU-local data" priority="0">
   <text priority="0">
    Library level data structures without special aspects (e.g. address clauses)
    are private, meaning each CPU has their own, local copy. This is achieved by
    providing each CPU with separate copies of the necessary ELF binary sections
    (\texttt{.data} and \texttt{.bss}). Only the memory regions of sections
    belonging to a given CPU are mapped into the address space of that
    particular kernel.
   </text>
   <section id="datamodel_cpulocal_init" label="Initialization" priority="0">
    <text priority="0">
     Initialization is performed by each CPU during Elaboration via a call to
     adainit in the assembly startup code.
    </text>
   </section>
  </section>
  <section id="datamodel_local_subject" label="Local subject-related data" priority="0">
   <text priority="0">
    Data structures associated with subjects, such as subject state, are
    implemented as arrays where each element is associated with a particular
    subject. The global subject ID is used as an index into the array to link an
    element to a specific subject. The array elements are dimensioned to 4K so
    they can be mapped as independent memory pages.

    These arrays are placed at specific virtual memory addresses. Only the
    elements belonging to subjects executed by a given CPU are mapped into the
    address space of that particular kernel.
   </text>
   <section id="datamodel_local_subject_init" label="Initialization" priority="0">
    <text priority="0">
     Each element is initialized by the executing CPU when processing the
     \texttt{SK.Scheduler.Init\_Subject} procedure during system
     initialization.
    </text>
   </section>
  </section>
  <section id="datamodel_global" label="Global shared data" priority="0">
   <text priority="0">
    Some data is accessed by all CPUs. This data is located in a separate,
    distinct ELF section (\texttt{.globaldata}) which is backed by a single
    physical memory region which is shared across all CPUs. Each kernel has a
    mapping of this region at the same memory location.

    \paragraph{Aspect Linker\_Section}
    Variable instances that are shared globally are placed in the ELF section
    \texttt{.globaldata} via use of the Ada \texttt{Linker\_Section} aspect.

    By convention affected variables are prefixed with \texttt{Global\_}.
   </text>
   <section id="datamodel_global_init" label="Initialization" priority="0">
    <text priority="0">
     Initialization is performed either via static initialization (if possible)
     or using explicit Initialization procedures that are only executed by a
     single CPU, i.e. the BSP.
    </text>
   </section>
  </section>
 </section>

 <section id="kernel_devices" label="Devices" priority="0">
  <text priority="0">
   This section describes what I/O devices the kernel uses and for what purpose.
  </text>
  <section id="kernel_devs_apic" label="Interrupt Controllers" priority="0">
   <text priority="0">
    This section describes how the kernel programs the PIC, APIC and I/O APIC.
   </text>
  </section>
  <section id="kernel_devs_iommu" label="IOMMU" priority="0">
   <text priority="0">
    This section describes how the kernel programs the IOMMU for device
    isolation, DMA and Interrupt remapping.
   </text>
  </section>
  <section id="kernel_devs_debug" label="Diagnostics" priority="0">
   <text priority="0">
    This section describes how the kernel debug build uses a serial I/O device
    for diagnostics output.
   </text>
  </section>
 </section>

 <section id="verification_and_validation" label="Verification" priority="20">
  <text priority="0">
   This section describes the methodology and techniques applied to the verification of Muen.
  </text>
  <section id="verification_spark" label="SPARK" priority="-10">
   <text priority="0">
    This section gives a short description of SPARK and its use in the context of Muen.
   </text>
  </section>
 </section>

 <section id="acronyms" label="Acronyms" priority="1000.0">
  <text priority="0">
   \begin{acronym}
    \acro{APIC}[APIC]{Advanced Programmable Interrupt Controller}
    \acro{AP}[AP]{Application Processor}
    \acro{BSP}[BSP]{Bootstrap Processor}
    \acro{SK}[SK]{Separation Kernel}
   \end{acronym}
  </text>
 </section>

</doc>
